# bcg-api-V1

---
<h3>SKILLS</h3>

* Gradle
  *Kotlin
* Spring Frmework
* JPA, Hibername
* Spring Data JPA
* QueryDSL
* MySQL, H2
* JUnit5, Mockito

---

# 초기설정 방법.

* h2설정
    * h2 db 다운로드 설치
        *
      참조 : https://atoz-develop.tistory.com/entry/H2-Database-%EC%84%A4%EC%B9%98-%EC%84%9C%EB%B2%84-%EC%8B%A4%ED%96%89-%EC%A0%91%EC%86%8D-%EB%B0%A9%EB%B2%95
        * 웬만하면 프로젝트 와 같은 root 폴더 경로에 설치해 주세요.
        * 최초 설치 후 터미널 또는 shell 등 열어서 실행하여 mv.db 생성
            * /h2/bin 이동 후
            * ./h2.sh 명령어로 실행
            * h2콘솔 로그인창(localhost:8082) 에서 JDBC URL 부분에 jdbc:h2:./bcgapi 로 적고 연결(사용자명 sa, 비밀번호 없음)
            * 연결 성공 하면 application.yml 참고하여 다음부터는 JDBC URL jdbc:h2:tcp://localhost/./bcgapi 로 연결
        * h2 실행 후 스프링부트를 띄워보기
            * JdbcSQLNonTransientConnectionException 뜬다면 h2 다시 띄워서 확인하기
            * http://localhost:8080/ 접속하여 Whitelabel Error Page 보이면 정상적임.
            * 스프링부트 run 화면에서 테이블 생성 확인 가능.

* 읽어보면 좋을 듯한 것
    * https://devwithpug.github.io/java/querydsl-with-datajpa/

# tdd 란 대충이라도 알고 가자~

* 창시자 : 켄트 백 - "프로그램 작성 전 테스트를 먼저 하라."
* tdd 란 - 테스트 코드를 먼저 만들고 -> 프로덕션 코드를 나중에 만드는 개발 방법.
    * 기존 - 설계 -> 개발 -> 테스트
    * tdd - 설계 < - >(설계수정) 테스트 코드 -> 개발
* tdd cycle - red, green, Refactor
    * 1.실패하는 테스트를 구현한다.
    * 2.테스트가 성공하도록 프로덕션 코드를 구현.
    * 3.프로덕션 코드와 테스트 코드를 리펙터링.
* 왜 사용해야 할까?
    * 리펙터링이 편하다
    * 디버깅 시간을 줄여준다.
    * 동작하는 문서 역할을 한다.
    * 오버엔지니어링 방지 - tdd 를 하면 요구사항에 맞추어 개발 코드를 구현하니 내가 필요한 만큼만 코딩을 할 수 있고, 미래의 코드까지 지레짐작하여 불필요한 코드 생성을 방지한다.
    * 설계에 대한 피드백이 빠르다.
        * 테스트 코드를 작성시 설계가 잘못되었다면 테스트 코드 작성이 매우 힘들어 지고, 빨리 발견될 수 있다.
    * TDD 는 설계방법론이 아니다
        * TDD 는 높은 응집을 유도하지 않으며,
        * 단일 책임 원칙과 인터페이스 분리 원칙 위배에 어떤 신호도 주지 않는다
        * 인터페이스 일관성을 도출하지 않는다.
        * 리펙터링 단계는 좋은 구조를 안내하거나 좋은 구조를 갖도록 강제하지 않는다.
        * TDD 로만 설계를 가져가는건 무리데스.

    * TDD 이러면 실패합니다.
        * 코드가 이루고자 하는 가치나 기능을 테스트
            * 구현체가 아닌 인터페이스를 테스트 해야한다.(ocp)
            * 내부 구현체과 변화해도 인터페이스를 테스트하면 깨지지 않는다.
                * tmi - 객체지향 설계 5원칙.(궁금하면 물어보삼~)
                    * srp - 단일 책임 원칙
                    * ocp - 개방 폐쇠 원칙
                    * lsp - 리스코프 치환 원칙
                    * isp - 인터페이스 분리 원칙
                    * dip - 의존역전의 원칙
            * 결국 테스트 케이스들의 결합도가 높아진다.
            * 구현체들을 리펙터링 하면 결합되어 있는 테스트 케이스들이 모두 깨진다.

    * 테스트 범위
        * ![img.png](img.png)
    * 단위테스트 - UnitTest
        * 메서드 레벨의 테스트를 진행하고 검증이 필요한 코드에 대한 코드를 작성한다.
        * 목적
            * 문제점 발견 - 각 단위가 정확히 동작하는지 검사하고 문제 발견시 빨리 확인할 수 있게 해줍니다. 그로인해 프로그램 안정성이 높아집니다.
            * 변경이 쉽다. 코드를 고치더라도 문제 점 및 수정된 코드 테스트를 쉽게 수 있게 됩니다.
            * 품질이 향상된다 - 하나의 단위가 너무 길어지거나 복잡해 지면 프로덕션 코드에서 잘못됬다 할 수 있다. 이러한 경우에는 리펙터링이 필요하다
            * 코드의 문서화가 가능하다. 샘플코드 -> 예외 상황, 용도, 의존 관계를 쉽게 알 수 있다.
            * 단위테스트는 배포되는 코드와 일치하므로, 항상 최신상태로 유지된다는 점도 있다.

* 좋은 단위 테스트 F.I.R.S.T 법칙
    * F - fast : 빠르게
        * 태스트는 빨라야 한다. 느리면 테스트를 자주 돌리기 힘들다 - 문제점을 찾아서 리펙터링 하자.
    * I - Independent : 독립적으로
        * 서로 의존하면 안된다. 하나가 실패하면 연쇄반응으로 실패하여 원인을 진단하기 힘들다.
    * R - Repeatable : 반복 가능하게
        * 어떠한 환경에서도 반복가능해야한다. 네트워크가 연결되어 있지 않아도 가능해야한다.그래야 변명을 못댐..ㅎ
    * S - Self-Validating : 자가 검증하는
        * 테스트 결과는 성공 도는 실패뿐이다.
    * T - Timely : 적시에
        * 테스트는 코드 작성 전에 항상 먼저 작성한다.뒤늦게 테스트 하기 힘들다고 또는 설계의 문제점을 알게된다.


* 개인적인
    * 테스트 커버리지 100 % (토스) : https://www.youtube.com/watch?v=jdlBu2vFv58
    * 이 문제 답 모르면 제발 JPA 쓰지 마세요. 공부를 하거나. https://www.youtube.com/watch?v=brE0tYOV9jQ